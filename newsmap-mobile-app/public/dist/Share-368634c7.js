
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, N as create_slot, v as validate_slots, e as element, b as space, t as text, f as attr_dev, O as toggle_class, c as add_location, h as insert_dev, j as append_dev, P as update_slot_base, Q as get_all_dirty_from_scope, R as get_slot_changes, a6 as set_data_dev, E as transition_in, G as transition_out, l as detach_dev, K as assign, ah as compute_rest_props, ai as exclude_internal_props, A as create_component, B as mount_component, M as get_spread_update, ag as get_spread_object, H as destroy_component, a as svg_element, F as Fa, aj as faShare, a3 as src_url_equal } from './main-477e1cc7.js';

/* node_modules\svelte-share-buttons-component\src\ShareButton.svelte generated by Svelte v3.46.4 */

const file$4 = "node_modules\\svelte-share-buttons-component\\src\\ShareButton.svelte";

function create_fragment$4(ctx) {
	let a;
	let div1;
	let div0;
	let t0;
	let t1;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			a = element("a");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr_dev(div0, "aria-hidden", "true");
			attr_dev(div0, "class", "ssbc-button__icon svelte-abzkh4");
			toggle_class(div0, "ssbc-button__icon--fill", /*fill*/ ctx[2]);
			toggle_class(div0, "ssbc-button__icon--outline", !/*fill*/ ctx[2]);
			add_location(div0, file$4, 46, 4, 748);
			attr_dev(div1, "class", div1_class_value = "ssbc-button " + /*classes*/ ctx[4] + " svelte-abzkh4");
			add_location(div1, file$4, 45, 2, 708);
			attr_dev(a, "class", "ssbc-button__link svelte-abzkh4");
			attr_dev(a, "href", /*href*/ ctx[0]);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "rel", "noopener");
			attr_dev(a, "aria-label", /*ariaLabel*/ ctx[3]);
			add_location(a, file$4, 44, 0, 615);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div1, t0);
			append_dev(div1, t1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (dirty & /*fill*/ 4) {
				toggle_class(div0, "ssbc-button__icon--fill", /*fill*/ ctx[2]);
			}

			if (dirty & /*fill*/ 4) {
				toggle_class(div0, "ssbc-button__icon--outline", !/*fill*/ ctx[2]);
			}

			if (!current || dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);

			if (!current || dirty & /*classes*/ 16 && div1_class_value !== (div1_class_value = "ssbc-button " + /*classes*/ ctx[4] + " svelte-abzkh4")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*href*/ 1) {
				attr_dev(a, "href", /*href*/ ctx[0]);
			}

			if (!current || dirty & /*ariaLabel*/ 8) {
				attr_dev(a, "aria-label", /*ariaLabel*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShareButton', slots, ['default']);
	let { href } = $$props;
	let { label = '' } = $$props;
	let { fill = true } = $$props;
	let { ariaLabel = '' } = $$props;
	let { class: classes = '' } = $$props;
	const writable_props = ['href', 'label', 'fill', 'ariaLabel', 'class'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareButton> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('href' in $$props) $$invalidate(0, href = $$props.href);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('fill' in $$props) $$invalidate(2, fill = $$props.fill);
		if ('ariaLabel' in $$props) $$invalidate(3, ariaLabel = $$props.ariaLabel);
		if ('class' in $$props) $$invalidate(4, classes = $$props.class);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ href, label, fill, ariaLabel, classes });

	$$self.$inject_state = $$props => {
		if ('href' in $$props) $$invalidate(0, href = $$props.href);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('fill' in $$props) $$invalidate(2, fill = $$props.fill);
		if ('ariaLabel' in $$props) $$invalidate(3, ariaLabel = $$props.ariaLabel);
		if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [href, label, fill, ariaLabel, classes, $$scope, slots];
}

class ShareButton extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			href: 0,
			label: 1,
			fill: 2,
			ariaLabel: 3,
			class: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShareButton",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*href*/ ctx[0] === undefined && !('href' in props)) {
			console.warn("<ShareButton> was created without expected prop 'href'");
		}
	}

	get href() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var ShareButton$1 = ShareButton;

/* node_modules\svelte-share-buttons-component\src\Facebook.svelte generated by Svelte v3.46.4 */
const file$3 = "node_modules\\svelte-share-buttons-component\\src\\Facebook.svelte";

// (26:0) <ShareButton class="ssbc-button--facebook {classes}" {...$$restProps} {ariaLabel} {href}>
function create_default_slot$2(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M18.77 7.46H14.5v-1.9c0-.9.6-1.1 1-1.1h3V.5h-4.33C10.24.5 9.5 3.44 9.5 5.32v2.15h-3v4h3v12h5v-12h3.85l.42-4z");
			add_location(path, file$3, 27, 4, 663);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 24 24");
			add_location(svg, file$3, 26, 2, 598);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(26:0) <ShareButton class=\\\"ssbc-button--facebook {classes}\\\" {...$$restProps} {ariaLabel} {href}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let sharebutton;
	let current;

	const sharebutton_spread_levels = [
		{
			class: "ssbc-button--facebook " + /*classes*/ ctx[1]
		},
		/*$$restProps*/ ctx[3],
		{ ariaLabel: /*ariaLabel*/ ctx[0] },
		{ href: /*href*/ ctx[2] }
	];

	let sharebutton_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < sharebutton_spread_levels.length; i += 1) {
		sharebutton_props = assign(sharebutton_props, sharebutton_spread_levels[i]);
	}

	sharebutton = new ShareButton$1({ props: sharebutton_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(sharebutton.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(sharebutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const sharebutton_changes = (dirty & /*classes, $$restProps, ariaLabel, href*/ 15)
			? get_spread_update(sharebutton_spread_levels, [
					dirty & /*classes*/ 2 && {
						class: "ssbc-button--facebook " + /*classes*/ ctx[1]
					},
					dirty & /*$$restProps*/ 8 && get_spread_object(/*$$restProps*/ ctx[3]),
					dirty & /*ariaLabel*/ 1 && { ariaLabel: /*ariaLabel*/ ctx[0] },
					dirty & /*href*/ 4 && { href: /*href*/ ctx[2] }
				])
			: {};

			if (dirty & /*$$scope*/ 64) {
				sharebutton_changes.$$scope = { dirty, ctx };
			}

			sharebutton.$set(sharebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sharebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sharebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sharebutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["quote","url","ariaLabel","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Facebook', slots, []);
	let { quote } = $$props;
	let { url } = $$props;
	let { ariaLabel = 'Share on Facebook' } = $$props;
	let { class: classes = '' } = $$props;
	let href;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('quote' in $$new_props) $$invalidate(4, quote = $$new_props.quote);
		if ('url' in $$new_props) $$invalidate(5, url = $$new_props.url);
		if ('ariaLabel' in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('class' in $$new_props) $$invalidate(1, classes = $$new_props.class);
	};

	$$self.$capture_state = () => ({
		quote,
		url,
		ariaLabel,
		classes,
		ShareButton: ShareButton$1,
		href
	});

	$$self.$inject_state = $$new_props => {
		if ('quote' in $$props) $$invalidate(4, quote = $$new_props.quote);
		if ('url' in $$props) $$invalidate(5, url = $$new_props.url);
		if ('ariaLabel' in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ('href' in $$props) $$invalidate(2, href = $$new_props.href);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*url, quote*/ 48) {
			$$invalidate(2, href = encodeURI(`https://facebook.com/sharer/sharer.php?u=${url}&quote=${quote}`));
		}
	};

	return [ariaLabel, classes, href, $$restProps, quote, url];
}

class Facebook extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { quote: 4, url: 5, ariaLabel: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Facebook",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*quote*/ ctx[4] === undefined && !('quote' in props)) {
			console.warn("<Facebook> was created without expected prop 'quote'");
		}

		if (/*url*/ ctx[5] === undefined && !('url' in props)) {
			console.warn("<Facebook> was created without expected prop 'url'");
		}
	}

	get quote() {
		throw new Error("<Facebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set quote(value) {
		throw new Error("<Facebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Facebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Facebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Facebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Facebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Facebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Facebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Facebook$1 = Facebook;

/* node_modules\svelte-share-buttons-component\src\Twitter.svelte generated by Svelte v3.46.4 */
const file$2 = "node_modules\\svelte-share-buttons-component\\src\\Twitter.svelte";

// (29:0) <ShareButton class="ssbc-button--twitter {classes}" {...$$restProps} {ariaLabel} {href}>
function create_default_slot$1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M23.44 4.83c-.8.37-1.5.38-2.22.02.93-.56.98-.96 1.32-2.02-.88.52-1.86.9-2.9 1.1-.82-.88-2-1.43-3.3-1.43-2.5 0-4.55 2.04-4.55 4.54 0 .36.03.7.1 1.04-3.77-.2-7.12-2-9.36-4.75-.4.67-.6 1.45-.6 2.3 0 1.56.8 2.95 2 3.77-.74-.03-1.44-.23-2.05-.57v.06c0 2.2 1.56 4.03 3.64 4.44-.67.2-1.37.2-2.06.08.58 1.8 2.26 3.12 4.25 3.16C5.78 18.1 3.37 18.74 1 18.46c2 1.3 4.4 2.04 6.97 2.04 8.35 0 12.92-6.92 12.92-12.93 0-.2 0-.4-.02-.6.9-.63 1.96-1.22 2.56-2.14z");
			add_location(path, file$2, 30, 4, 779);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 24 24");
			add_location(svg, file$2, 29, 2, 714);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(29:0) <ShareButton class=\\\"ssbc-button--twitter {classes}\\\" {...$$restProps} {ariaLabel} {href}>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let sharebutton;
	let current;

	const sharebutton_spread_levels = [
		{
			class: "ssbc-button--twitter " + /*classes*/ ctx[1]
		},
		/*$$restProps*/ ctx[3],
		{ ariaLabel: /*ariaLabel*/ ctx[0] },
		{ href: /*href*/ ctx[2] }
	];

	let sharebutton_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < sharebutton_spread_levels.length; i += 1) {
		sharebutton_props = assign(sharebutton_props, sharebutton_spread_levels[i]);
	}

	sharebutton = new ShareButton$1({ props: sharebutton_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(sharebutton.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(sharebutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const sharebutton_changes = (dirty & /*classes, $$restProps, ariaLabel, href*/ 15)
			? get_spread_update(sharebutton_spread_levels, [
					dirty & /*classes*/ 2 && {
						class: "ssbc-button--twitter " + /*classes*/ ctx[1]
					},
					dirty & /*$$restProps*/ 8 && get_spread_object(/*$$restProps*/ ctx[3]),
					dirty & /*ariaLabel*/ 1 && { ariaLabel: /*ariaLabel*/ ctx[0] },
					dirty & /*href*/ 4 && { href: /*href*/ ctx[2] }
				])
			: {};

			if (dirty & /*$$scope*/ 512) {
				sharebutton_changes.$$scope = { dirty, ctx };
			}

			sharebutton.$set(sharebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sharebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sharebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sharebutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["text","url","ariaLabel","hashtags","via","related","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Twitter', slots, []);
	let { text } = $$props;
	let { url } = $$props;
	let { ariaLabel = 'Share on Twitter' } = $$props;
	let { hashtags = '' } = $$props;
	let { via = '' } = $$props;
	let { related = '' } = $$props;
	let { class: classes = '' } = $$props;
	let href;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('text' in $$new_props) $$invalidate(4, text = $$new_props.text);
		if ('url' in $$new_props) $$invalidate(5, url = $$new_props.url);
		if ('ariaLabel' in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('hashtags' in $$new_props) $$invalidate(6, hashtags = $$new_props.hashtags);
		if ('via' in $$new_props) $$invalidate(7, via = $$new_props.via);
		if ('related' in $$new_props) $$invalidate(8, related = $$new_props.related);
		if ('class' in $$new_props) $$invalidate(1, classes = $$new_props.class);
	};

	$$self.$capture_state = () => ({
		text,
		url,
		ariaLabel,
		hashtags,
		via,
		related,
		classes,
		ShareButton: ShareButton$1,
		href
	});

	$$self.$inject_state = $$new_props => {
		if ('text' in $$props) $$invalidate(4, text = $$new_props.text);
		if ('url' in $$props) $$invalidate(5, url = $$new_props.url);
		if ('ariaLabel' in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('hashtags' in $$props) $$invalidate(6, hashtags = $$new_props.hashtags);
		if ('via' in $$props) $$invalidate(7, via = $$new_props.via);
		if ('related' in $$props) $$invalidate(8, related = $$new_props.related);
		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ('href' in $$props) $$invalidate(2, href = $$new_props.href);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*text, hashtags, via, related, url*/ 496) {
			$$invalidate(2, href = encodeURI(`https://twitter.com/intent/tweet/?text=${text}&hashtags=${hashtags}&via=${via}&related=${related}&url=${url}`));
		}
	};

	return [ariaLabel, classes, href, $$restProps, text, url, hashtags, via, related];
}

class Twitter extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			text: 4,
			url: 5,
			ariaLabel: 0,
			hashtags: 6,
			via: 7,
			related: 8,
			class: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Twitter",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*text*/ ctx[4] === undefined && !('text' in props)) {
			console.warn("<Twitter> was created without expected prop 'text'");
		}

		if (/*url*/ ctx[5] === undefined && !('url' in props)) {
			console.warn("<Twitter> was created without expected prop 'url'");
		}
	}

	get text() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hashtags() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hashtags(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get via() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set via(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get related() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set related(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Twitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Twitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Twitter$1 = Twitter;

/* node_modules\svelte-share-buttons-component\src\WhatsApp.svelte generated by Svelte v3.46.4 */
const file$1 = "node_modules\\svelte-share-buttons-component\\src\\WhatsApp.svelte";

// (25:0) <ShareButton class="ssbc-button--whatsapp {classes}" {...$$restProps} {ariaLabel} {href}>
function create_default_slot(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M20.1 3.9C17.9 1.7 15 .5 12 .5 5.8.5.7 5.6.7 11.9c0 2 .5 3.9 1.5 5.6L.6 23.4l6-1.6c1.6.9 3.5 1.3 5.4 1.3 6.3 0 11.4-5.1 11.4-11.4-.1-2.8-1.2-5.7-3.3-7.8zM12 21.4c-1.7 0-3.3-.5-4.8-1.3l-.4-.2-3.5 1 1-3.4L4 17c-1-1.5-1.4-3.2-1.4-5.1 0-5.2 4.2-9.4 9.4-9.4 2.5 0 4.9 1 6.7 2.8 1.8 1.8 2.8 4.2 2.8 6.7-.1 5.2-4.3 9.4-9.5 9.4zm5.1-7.1c-.3-.1-1.7-.9-1.9-1-.3-.1-.5-.1-.7.1-.2.3-.8 1-.9 1.1-.2.2-.3.2-.6.1s-1.2-.5-2.3-1.4c-.9-.8-1.4-1.7-1.6-2-.2-.3 0-.5.1-.6s.3-.3.4-.5c.2-.1.3-.3.4-.5.1-.2 0-.4 0-.5C10 9 9.3 7.6 9 7c-.1-.4-.4-.3-.5-.3h-.6s-.4.1-.7.3c-.3.3-1 1-1 2.4s1 2.8 1.1 3c.1.2 2 3.1 4.9 4.3.7.3 1.2.5 1.6.6.7.2 1.3.2 1.8.1.6-.1 1.7-.7 1.9-1.3.2-.7.2-1.2.2-1.3-.1-.3-.3-.4-.6-.5z");
			add_location(path, file$1, 26, 4, 610);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 24 24");
			add_location(svg, file$1, 25, 2, 545);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(25:0) <ShareButton class=\\\"ssbc-button--whatsapp {classes}\\\" {...$$restProps} {ariaLabel} {href}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let sharebutton;
	let current;

	const sharebutton_spread_levels = [
		{
			class: "ssbc-button--whatsapp " + /*classes*/ ctx[1]
		},
		/*$$restProps*/ ctx[3],
		{ ariaLabel: /*ariaLabel*/ ctx[0] },
		{ href: /*href*/ ctx[2] }
	];

	let sharebutton_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < sharebutton_spread_levels.length; i += 1) {
		sharebutton_props = assign(sharebutton_props, sharebutton_spread_levels[i]);
	}

	sharebutton = new ShareButton$1({ props: sharebutton_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(sharebutton.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(sharebutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const sharebutton_changes = (dirty & /*classes, $$restProps, ariaLabel, href*/ 15)
			? get_spread_update(sharebutton_spread_levels, [
					dirty & /*classes*/ 2 && {
						class: "ssbc-button--whatsapp " + /*classes*/ ctx[1]
					},
					dirty & /*$$restProps*/ 8 && get_spread_object(/*$$restProps*/ ctx[3]),
					dirty & /*ariaLabel*/ 1 && { ariaLabel: /*ariaLabel*/ ctx[0] },
					dirty & /*href*/ 4 && { href: /*href*/ ctx[2] }
				])
			: {};

			if (dirty & /*$$scope*/ 32) {
				sharebutton_changes.$$scope = { dirty, ctx };
			}

			sharebutton.$set(sharebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sharebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sharebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sharebutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["text","ariaLabel","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('WhatsApp', slots, []);
	let { text } = $$props;
	let { ariaLabel = 'Share on WhatsApp' } = $$props;
	let { class: classes = '' } = $$props;
	let href;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('text' in $$new_props) $$invalidate(4, text = $$new_props.text);
		if ('ariaLabel' in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('class' in $$new_props) $$invalidate(1, classes = $$new_props.class);
	};

	$$self.$capture_state = () => ({
		text,
		ariaLabel,
		classes,
		ShareButton: ShareButton$1,
		href
	});

	$$self.$inject_state = $$new_props => {
		if ('text' in $$props) $$invalidate(4, text = $$new_props.text);
		if ('ariaLabel' in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ('href' in $$props) $$invalidate(2, href = $$new_props.href);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*text*/ 16) {
			$$invalidate(2, href = encodeURI(`whatsapp://send?text=${text}`));
		}
	};

	return [ariaLabel, classes, href, $$restProps, text];
}

class WhatsApp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { text: 4, ariaLabel: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WhatsApp",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*text*/ ctx[4] === undefined && !('text' in props)) {
			console.warn("<WhatsApp> was created without expected prop 'text'");
		}
	}

	get text() {
		throw new Error("<WhatsApp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<WhatsApp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<WhatsApp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<WhatsApp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<WhatsApp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<WhatsApp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var WhatsApp$1 = WhatsApp;

/* src\Share.svelte generated by Svelte v3.46.4 */
const file = "src\\Share.svelte";

function create_fragment(ctx) {
	let whatsapp;
	let t0;
	let facebook;
	let t1;
	let twitter;
	let t2;
	let a;
	let div;
	let img;
	let img_src_value;
	let current;

	whatsapp = new WhatsApp$1({
			props: {
				class: "share-button sb1",
				text: "" + (/*title*/ ctx[1] + " " + /*url*/ ctx[0])
			},
			$$inline: true
		});

	facebook = new Facebook$1({
			props: {
				class: "share-button sb2",
				quote: /*title*/ ctx[1],
				url: /*url*/ ctx[0]
			},
			$$inline: true
		});

	twitter = new Twitter$1({
			props: {
				class: "share-button sb3",
				text: /*title*/ ctx[1],
				url: /*url*/ ctx[0],
				via: "jurno_id"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(whatsapp.$$.fragment);
			t0 = space();
			create_component(facebook.$$.fragment);
			t1 = space();
			create_component(twitter.$$.fragment);
			t2 = space();
			a = element("a");
			div = element("div");
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = "./images/jurno.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "back");
			attr_dev(img, "class", "svelte-1m8uy1k");
			add_location(img, file, 21, 12, 571);
			attr_dev(div, "class", "back svelte-1m8uy1k");
			add_location(div, file, 20, 8, 539);
			attr_dev(a, "href", "/");
			add_location(a, file, 19, 4, 517);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(whatsapp, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(facebook, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(twitter, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, a, anchor);
			append_dev(a, div);
			append_dev(div, img);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const whatsapp_changes = {};
			if (dirty & /*title, url*/ 3) whatsapp_changes.text = "" + (/*title*/ ctx[1] + " " + /*url*/ ctx[0]);
			whatsapp.$set(whatsapp_changes);
			const facebook_changes = {};
			if (dirty & /*title*/ 2) facebook_changes.quote = /*title*/ ctx[1];
			if (dirty & /*url*/ 1) facebook_changes.url = /*url*/ ctx[0];
			facebook.$set(facebook_changes);
			const twitter_changes = {};
			if (dirty & /*title*/ 2) twitter_changes.text = /*title*/ ctx[1];
			if (dirty & /*url*/ 1) twitter_changes.url = /*url*/ ctx[0];
			twitter.$set(twitter_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(whatsapp.$$.fragment, local);
			transition_in(facebook.$$.fragment, local);
			transition_in(twitter.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(whatsapp.$$.fragment, local);
			transition_out(facebook.$$.fragment, local);
			transition_out(twitter.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(whatsapp, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(facebook, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(twitter, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Share', slots, []);
	let { url, title } = $$props;
	const writable_props = ['url', 'title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Share> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(0, url = $$props.url);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		WhatsApp: WhatsApp$1,
		Facebook: Facebook$1,
		Twitter: Twitter$1,
		Fa,
		faShare,
		url,
		title
	});

	$$self.$inject_state = $$props => {
		if ('url' in $$props) $$invalidate(0, url = $$props.url);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [url, title];
}

class Share extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { url: 0, title: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Share",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*url*/ ctx[0] === undefined && !('url' in props)) {
			console.warn("<Share> was created without expected prop 'url'");
		}

		if (/*title*/ ctx[1] === undefined && !('title' in props)) {
			console.warn("<Share> was created without expected prop 'title'");
		}
	}

	get url() {
		throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Share as S };
//# sourceMappingURL=Share-368634c7.js.map
