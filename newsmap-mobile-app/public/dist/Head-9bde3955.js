
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, K as assign, v as validate_slots, a as svg_element, L as set_svg_attributes, c as add_location, h as insert_dev, M as get_spread_update, n as noop, l as detach_dev, N as create_slot, f as attr_dev, O as toggle_class, P as update_slot_base, Q as get_all_dirty_from_scope, R as get_slot_changes, E as transition_in, G as transition_out, T as globals, A as create_component, B as mount_component, H as destroy_component, I as empty, V as group_outros, W as check_outros, b as space, X as validate_each_argument, Y as destroy_each, o as binding_callbacks, p as bind, C as add_flush_callback, F as Fa, e as element, g as set_style, j as append_dev, Z as listen_dev, k as action_destroyer, _ as run_all, $ as createEventDispatcher, a0 as set_input_value, a1 as add_render_callback, a2 as add_resize_listener, a3 as src_url_equal } from './main-1d28085c.js';
import { l as link } from './Router-3cee6396.js';

/* node_modules\svelte-awesome\components\svg\Path.svelte generated by Svelte v3.46.4 */

const file$6 = "node_modules\\svelte-awesome\\components\\svg\\Path.svelte";

function create_fragment$7(ctx) {
	let path;
	let path_id_value;

	let path_levels = [
		{
			id: path_id_value = "path-" + /*id*/ ctx[0]
		},
		/*data*/ ctx[1]
	];

	let path_data = {};

	for (let i = 0; i < path_levels.length; i += 1) {
		path_data = assign(path_data, path_levels[i]);
	}

	const block = {
		c: function create() {
			path = svg_element("path");
			set_svg_attributes(path, path_data);
			add_location(path, file$6, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_svg_attributes(path, path_data = get_spread_update(path_levels, [
				dirty & /*id*/ 1 && path_id_value !== (path_id_value = "path-" + /*id*/ ctx[0]) && { id: path_id_value },
				dirty & /*data*/ 2 && /*data*/ ctx[1]
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Path', slots, []);
	let { id } = $$props;
	let { data = {} } = $$props;
	const writable_props = ['id', 'data'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Path> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	$$self.$capture_state = () => ({ id, data });

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id, data];
}

class Path extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { id: 0, data: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Path",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !('id' in props)) {
			console.warn("<Path> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get data() {
		throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-awesome\components\svg\Polygon.svelte generated by Svelte v3.46.4 */

const file$5 = "node_modules\\svelte-awesome\\components\\svg\\Polygon.svelte";

function create_fragment$6(ctx) {
	let polygon;
	let polygon_id_value;

	let polygon_levels = [
		{
			id: polygon_id_value = "polygon-" + /*id*/ ctx[0]
		},
		/*data*/ ctx[1]
	];

	let polygon_data = {};

	for (let i = 0; i < polygon_levels.length; i += 1) {
		polygon_data = assign(polygon_data, polygon_levels[i]);
	}

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			set_svg_attributes(polygon, polygon_data);
			add_location(polygon, file$5, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, polygon, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [
				dirty & /*id*/ 1 && polygon_id_value !== (polygon_id_value = "polygon-" + /*id*/ ctx[0]) && { id: polygon_id_value },
				dirty & /*data*/ 2 && /*data*/ ctx[1]
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Polygon', slots, []);
	let { id } = $$props;
	let { data = {} } = $$props;
	const writable_props = ['id', 'data'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Polygon> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	$$self.$capture_state = () => ({ id, data });

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id, data];
}

class Polygon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { id: 0, data: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Polygon",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !('id' in props)) {
			console.warn("<Polygon> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get data() {
		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-awesome\components\svg\Raw.svelte generated by Svelte v3.46.4 */

const file$4 = "node_modules\\svelte-awesome\\components\\svg\\Raw.svelte";

function create_fragment$5(ctx) {
	let g;

	const block = {
		c: function create() {
			g = svg_element("g");
			add_location(g, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, g, anchor);
			g.innerHTML = /*raw*/ ctx[0];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*raw*/ 1) g.innerHTML = /*raw*/ ctx[0];		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Raw', slots, []);
	let cursor = 0xd4937;

	function getId() {
		cursor += 1;
		return `fa-${cursor.toString(16)}`;
	}

	let raw;
	let { data } = $$props;

	function getRaw(data) {
		if (!data || !data.raw) {
			return null;
		}

		let rawData = data.raw;
		const ids = {};

		rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
			const uniqueId = getId();
			ids[id] = uniqueId;
			return ` id="${uniqueId}"`;
		});

		rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
			const id = rawId || pointerId;

			if (!id || !ids[id]) {
				return match;
			}

			return `#${ids[id]}`;
		});

		return rawData;
	}

	const writable_props = ['data'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Raw> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	$$self.$capture_state = () => ({ cursor, getId, raw, data, getRaw });

	$$self.$inject_state = $$props => {
		if ('cursor' in $$props) cursor = $$props.cursor;
		if ('raw' in $$props) $$invalidate(0, raw = $$props.raw);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 2) {
			$$invalidate(0, raw = getRaw(data));
		}
	};

	return [raw, data];
}

class Raw extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { data: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Raw",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[1] === undefined && !('data' in props)) {
			console.warn("<Raw> was created without expected prop 'data'");
		}
	}

	get data() {
		throw new Error("<Raw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Raw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-awesome\components\svg\Svg.svelte generated by Svelte v3.46.4 */

const file$3 = "node_modules\\svelte-awesome\\components\\svg\\Svg.svelte";

function create_fragment$4(ctx) {
	let svg;
	let svg_class_value;
	let svg_role_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			attr_dev(svg, "version", "1.1");
			attr_dev(svg, "class", svg_class_value = "fa-icon " + /*className*/ ctx[0] + " svelte-1dof0an");
			attr_dev(svg, "x", /*x*/ ctx[8]);
			attr_dev(svg, "y", /*y*/ ctx[9]);
			attr_dev(svg, "width", /*width*/ ctx[1]);
			attr_dev(svg, "height", /*height*/ ctx[2]);
			attr_dev(svg, "aria-label", /*label*/ ctx[11]);
			attr_dev(svg, "role", svg_role_value = /*label*/ ctx[11] ? 'img' : 'presentation');
			attr_dev(svg, "viewBox", /*box*/ ctx[3]);
			attr_dev(svg, "style", /*style*/ ctx[10]);
			toggle_class(svg, "fa-spin", /*spin*/ ctx[4]);
			toggle_class(svg, "fa-pulse", /*pulse*/ ctx[6]);
			toggle_class(svg, "fa-inverse", /*inverse*/ ctx[5]);
			toggle_class(svg, "fa-flip-horizontal", /*flip*/ ctx[7] === 'horizontal');
			toggle_class(svg, "fa-flip-vertical", /*flip*/ ctx[7] === 'vertical');
			add_location(svg, file$3, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*className*/ 1 && svg_class_value !== (svg_class_value = "fa-icon " + /*className*/ ctx[0] + " svelte-1dof0an")) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (!current || dirty & /*x*/ 256) {
				attr_dev(svg, "x", /*x*/ ctx[8]);
			}

			if (!current || dirty & /*y*/ 512) {
				attr_dev(svg, "y", /*y*/ ctx[9]);
			}

			if (!current || dirty & /*width*/ 2) {
				attr_dev(svg, "width", /*width*/ ctx[1]);
			}

			if (!current || dirty & /*height*/ 4) {
				attr_dev(svg, "height", /*height*/ ctx[2]);
			}

			if (!current || dirty & /*label*/ 2048) {
				attr_dev(svg, "aria-label", /*label*/ ctx[11]);
			}

			if (!current || dirty & /*label*/ 2048 && svg_role_value !== (svg_role_value = /*label*/ ctx[11] ? 'img' : 'presentation')) {
				attr_dev(svg, "role", svg_role_value);
			}

			if (!current || dirty & /*box*/ 8) {
				attr_dev(svg, "viewBox", /*box*/ ctx[3]);
			}

			if (!current || dirty & /*style*/ 1024) {
				attr_dev(svg, "style", /*style*/ ctx[10]);
			}

			if (dirty & /*className, spin*/ 17) {
				toggle_class(svg, "fa-spin", /*spin*/ ctx[4]);
			}

			if (dirty & /*className, pulse*/ 65) {
				toggle_class(svg, "fa-pulse", /*pulse*/ ctx[6]);
			}

			if (dirty & /*className, inverse*/ 33) {
				toggle_class(svg, "fa-inverse", /*inverse*/ ctx[5]);
			}

			if (dirty & /*className, flip*/ 129) {
				toggle_class(svg, "fa-flip-horizontal", /*flip*/ ctx[7] === 'horizontal');
			}

			if (dirty & /*className, flip*/ 129) {
				toggle_class(svg, "fa-flip-vertical", /*flip*/ ctx[7] === 'vertical');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Svg', slots, ['default']);
	let { class: className } = $$props;
	let { width } = $$props;
	let { height } = $$props;
	let { box } = $$props;
	let { spin = false } = $$props;
	let { inverse = false } = $$props;
	let { pulse = false } = $$props;
	let { flip = null } = $$props;
	let { x = undefined } = $$props;
	let { y = undefined } = $$props;
	let { style = undefined } = $$props;
	let { label = undefined } = $$props;

	const writable_props = [
		'class',
		'width',
		'height',
		'box',
		'spin',
		'inverse',
		'pulse',
		'flip',
		'x',
		'y',
		'style',
		'label'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Svg> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, className = $$props.class);
		if ('width' in $$props) $$invalidate(1, width = $$props.width);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('box' in $$props) $$invalidate(3, box = $$props.box);
		if ('spin' in $$props) $$invalidate(4, spin = $$props.spin);
		if ('inverse' in $$props) $$invalidate(5, inverse = $$props.inverse);
		if ('pulse' in $$props) $$invalidate(6, pulse = $$props.pulse);
		if ('flip' in $$props) $$invalidate(7, flip = $$props.flip);
		if ('x' in $$props) $$invalidate(8, x = $$props.x);
		if ('y' in $$props) $$invalidate(9, y = $$props.y);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('label' in $$props) $$invalidate(11, label = $$props.label);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		className,
		width,
		height,
		box,
		spin,
		inverse,
		pulse,
		flip,
		x,
		y,
		style,
		label
	});

	$$self.$inject_state = $$props => {
		if ('className' in $$props) $$invalidate(0, className = $$props.className);
		if ('width' in $$props) $$invalidate(1, width = $$props.width);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('box' in $$props) $$invalidate(3, box = $$props.box);
		if ('spin' in $$props) $$invalidate(4, spin = $$props.spin);
		if ('inverse' in $$props) $$invalidate(5, inverse = $$props.inverse);
		if ('pulse' in $$props) $$invalidate(6, pulse = $$props.pulse);
		if ('flip' in $$props) $$invalidate(7, flip = $$props.flip);
		if ('x' in $$props) $$invalidate(8, x = $$props.x);
		if ('y' in $$props) $$invalidate(9, y = $$props.y);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('label' in $$props) $$invalidate(11, label = $$props.label);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		width,
		height,
		box,
		spin,
		inverse,
		pulse,
		flip,
		x,
		y,
		style,
		label,
		$$scope,
		slots
	];
}

class Svg extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			class: 0,
			width: 1,
			height: 2,
			box: 3,
			spin: 4,
			inverse: 5,
			pulse: 6,
			flip: 7,
			x: 8,
			y: 9,
			style: 10,
			label: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Svg",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*className*/ ctx[0] === undefined && !('class' in props)) {
			console.warn("<Svg> was created without expected prop 'class'");
		}

		if (/*width*/ ctx[1] === undefined && !('width' in props)) {
			console.warn("<Svg> was created without expected prop 'width'");
		}

		if (/*height*/ ctx[2] === undefined && !('height' in props)) {
			console.warn("<Svg> was created without expected prop 'height'");
		}

		if (/*box*/ ctx[3] === undefined && !('box' in props)) {
			console.warn("<Svg> was created without expected prop 'box'");
		}
	}

	get class() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get box() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set box(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spin() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spin(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inverse() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inverse(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pulse() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pulse(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flip() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flip(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get x() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set x(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get y() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set y(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-awesome\components\Icon.svelte generated by Svelte v3.46.4 */

const { Object: Object_1, console: console_1 } = globals;

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	child_ctx[31] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[31] = i;
	return child_ctx;
}

// (4:4) {#if self}
function create_if_block$2(ctx) {
	let t0;
	let t1;
	let if_block2_anchor;
	let current;
	let if_block0 = /*self*/ ctx[6].paths && create_if_block_3$1(ctx);
	let if_block1 = /*self*/ ctx[6].polygons && create_if_block_2$2(ctx);
	let if_block2 = /*self*/ ctx[6].raw && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*self*/ ctx[6].paths) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*self*/ 64) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*self*/ ctx[6].polygons) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*self*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*self*/ ctx[6].raw) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*self*/ 64) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(4:4) {#if self}",
		ctx
	});

	return block;
}

// (5:6) {#if self.paths}
function create_if_block_3$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = /*self*/ ctx[6].paths;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*self*/ 64) {
				each_value_1 = /*self*/ ctx[6].paths;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(5:6) {#if self.paths}",
		ctx
	});

	return block;
}

// (6:8) {#each self.paths as path, i}
function create_each_block_1(ctx) {
	let path;
	let current;

	path = new Path({
			props: {
				id: /*i*/ ctx[31],
				data: /*path*/ ctx[32]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(path.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(path, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const path_changes = {};
			if (dirty[0] & /*self*/ 64) path_changes.data = /*path*/ ctx[32];
			path.$set(path_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(path.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(path.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(path, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(6:8) {#each self.paths as path, i}",
		ctx
	});

	return block;
}

// (10:6) {#if self.polygons}
function create_if_block_2$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*self*/ ctx[6].polygons;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*self*/ 64) {
				each_value = /*self*/ ctx[6].polygons;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(10:6) {#if self.polygons}",
		ctx
	});

	return block;
}

// (11:8) {#each self.polygons as polygon, i}
function create_each_block(ctx) {
	let polygon;
	let current;

	polygon = new Polygon({
			props: {
				id: /*i*/ ctx[31],
				data: /*polygon*/ ctx[29]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(polygon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(polygon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const polygon_changes = {};
			if (dirty[0] & /*self*/ 64) polygon_changes.data = /*polygon*/ ctx[29];
			polygon.$set(polygon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(polygon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(polygon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(polygon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(11:8) {#each self.polygons as polygon, i}",
		ctx
	});

	return block;
}

// (15:6) {#if self.raw}
function create_if_block_1$2(ctx) {
	let raw;
	let updating_data;
	let current;

	function raw_data_binding(value) {
		/*raw_data_binding*/ ctx[15](value);
	}

	let raw_props = {};

	if (/*self*/ ctx[6] !== void 0) {
		raw_props.data = /*self*/ ctx[6];
	}

	raw = new Raw({ props: raw_props, $$inline: true });
	binding_callbacks.push(() => bind(raw, 'data', raw_data_binding));

	const block = {
		c: function create() {
			create_component(raw.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(raw, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const raw_changes = {};

			if (!updating_data && dirty[0] & /*self*/ 64) {
				updating_data = true;
				raw_changes.data = /*self*/ ctx[6];
				add_flush_callback(() => updating_data = false);
			}

			raw.$set(raw_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(raw.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(raw.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(raw, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(15:6) {#if self.raw}",
		ctx
	});

	return block;
}

// (3:8)      
function fallback_block(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*self*/ ctx[6] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*self*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*self*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(3:8)      ",
		ctx
	});

	return block;
}

// (1:0) <Svg label={label} width={width} height={height} box={box} style={combinedStyle}   spin={spin} flip={flip} inverse={inverse} pulse={pulse} class={className}>
function create_default_slot(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*self*/ 64)) {
					default_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(1:0) <Svg label={label} width={width} height={height} box={box} style={combinedStyle}   spin={spin} flip={flip} inverse={inverse} pulse={pulse} class={className}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let svg;
	let current;

	svg = new Svg({
			props: {
				label: /*label*/ ctx[5],
				width: /*width*/ ctx[7],
				height: /*height*/ ctx[8],
				box: /*box*/ ctx[10],
				style: /*combinedStyle*/ ctx[9],
				spin: /*spin*/ ctx[1],
				flip: /*flip*/ ctx[4],
				inverse: /*inverse*/ ctx[2],
				pulse: /*pulse*/ ctx[3],
				class: /*className*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(svg.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(svg, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const svg_changes = {};
			if (dirty[0] & /*label*/ 32) svg_changes.label = /*label*/ ctx[5];
			if (dirty[0] & /*width*/ 128) svg_changes.width = /*width*/ ctx[7];
			if (dirty[0] & /*height*/ 256) svg_changes.height = /*height*/ ctx[8];
			if (dirty[0] & /*box*/ 1024) svg_changes.box = /*box*/ ctx[10];
			if (dirty[0] & /*combinedStyle*/ 512) svg_changes.style = /*combinedStyle*/ ctx[9];
			if (dirty[0] & /*spin*/ 2) svg_changes.spin = /*spin*/ ctx[1];
			if (dirty[0] & /*flip*/ 16) svg_changes.flip = /*flip*/ ctx[4];
			if (dirty[0] & /*inverse*/ 4) svg_changes.inverse = /*inverse*/ ctx[2];
			if (dirty[0] & /*pulse*/ 8) svg_changes.pulse = /*pulse*/ ctx[3];
			if (dirty[0] & /*className*/ 1) svg_changes.class = /*className*/ ctx[0];

			if (dirty[0] & /*$$scope, self*/ 65600) {
				svg_changes.$$scope = { dirty, ctx };
			}

			svg.$set(svg_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(svg.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(svg.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(svg, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function normaliseData(data) {
	if ('iconName' in data && 'icon' in data) {
		let normalisedData = {};
		let faIcon = data.icon;
		let name = data.iconName;
		let width = faIcon[0];
		let height = faIcon[1];
		let paths = faIcon[4];
		let iconData = { width, height, paths: [{ d: paths }] };
		normalisedData[name] = iconData;
		return normalisedData;
	}

	return data;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Icon', slots, ['default']);
	let { class: className = "" } = $$props;
	let { data } = $$props;
	let { scale = 1 } = $$props;
	let { spin = false } = $$props;
	let { inverse = false } = $$props;
	let { pulse = false } = $$props;
	let { flip = null } = $$props;
	let { label = null } = $$props;
	let self = null;
	let { style = null } = $$props;

	// internal
	let x = 0;

	let y = 0;
	let childrenHeight = 0;
	let childrenWidth = 0;
	let outerScale = 1;
	let width;
	let height;
	let combinedStyle;
	let box;

	function init() {
		if (typeof data === 'undefined') {
			return;
		}

		const normalisedData = normaliseData(data);
		const [name] = Object.keys(normalisedData);
		const icon = normalisedData[name];

		if (!icon.paths) {
			icon.paths = [];
		}

		if (icon.d) {
			icon.paths.push({ d: icon.d });
		}

		if (!icon.polygons) {
			icon.polygons = [];
		}

		if (icon.points) {
			icon.polygons.push({ points: icon.points });
		}

		$$invalidate(6, self = icon);
	}

	function normalisedScale() {
		let numScale = 1;

		if (typeof scale !== 'undefined') {
			numScale = Number(scale);
		}

		if (isNaN(numScale) || numScale <= 0) {
			// eslint-disable-line no-restricted-globals
			console.warn('Invalid prop: prop "scale" should be a number over 0.'); // eslint-disable-line no-console

			return outerScale;
		}

		return numScale * outerScale;
	}

	function calculateBox() {
		if (self) {
			return `0 0 ${self.width} ${self.height}`;
		}

		return `0 0 ${width} ${height}`;
	}

	function calculateRatio() {
		if (!self) {
			return 1;
		}

		return Math.max(self.width, self.height) / 16;
	}

	function calculateWidth() {
		if (childrenWidth) {
			return childrenWidth;
		}

		if (self) {
			return self.width / calculateRatio() * normalisedScale();
		}

		return 0;
	}

	function calculateHeight() {
		if (childrenHeight) {
			return childrenHeight;
		}

		if (self) {
			return self.height / calculateRatio() * normalisedScale();
		}

		return 0;
	}

	function calculateStyle() {
		let combined = "";

		if (style !== null) {
			combined += style;
		}

		let size = normalisedScale();

		if (size === 1) {
			if (combined.length === 0) {
				return undefined;
			}

			return combined;
		}

		if (combined !== "" && !combined.endsWith(';')) {
			combined += '; ';
		}

		return `${combined}font-size: ${size}em`;
	}

	const writable_props = ['class', 'data', 'scale', 'spin', 'inverse', 'pulse', 'flip', 'label', 'style'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	function raw_data_binding(value) {
		self = value;
		$$invalidate(6, self);
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, className = $$props.class);
		if ('data' in $$props) $$invalidate(11, data = $$props.data);
		if ('scale' in $$props) $$invalidate(12, scale = $$props.scale);
		if ('spin' in $$props) $$invalidate(1, spin = $$props.spin);
		if ('inverse' in $$props) $$invalidate(2, inverse = $$props.inverse);
		if ('pulse' in $$props) $$invalidate(3, pulse = $$props.pulse);
		if ('flip' in $$props) $$invalidate(4, flip = $$props.flip);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Path,
		Polygon,
		Raw,
		Svg,
		className,
		data,
		scale,
		spin,
		inverse,
		pulse,
		flip,
		label,
		self,
		style,
		x,
		y,
		childrenHeight,
		childrenWidth,
		outerScale,
		width,
		height,
		combinedStyle,
		box,
		init,
		normaliseData,
		normalisedScale,
		calculateBox,
		calculateRatio,
		calculateWidth,
		calculateHeight,
		calculateStyle
	});

	$$self.$inject_state = $$props => {
		if ('className' in $$props) $$invalidate(0, className = $$props.className);
		if ('data' in $$props) $$invalidate(11, data = $$props.data);
		if ('scale' in $$props) $$invalidate(12, scale = $$props.scale);
		if ('spin' in $$props) $$invalidate(1, spin = $$props.spin);
		if ('inverse' in $$props) $$invalidate(2, inverse = $$props.inverse);
		if ('pulse' in $$props) $$invalidate(3, pulse = $$props.pulse);
		if ('flip' in $$props) $$invalidate(4, flip = $$props.flip);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('self' in $$props) $$invalidate(6, self = $$props.self);
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
		if ('x' in $$props) x = $$props.x;
		if ('y' in $$props) y = $$props.y;
		if ('childrenHeight' in $$props) childrenHeight = $$props.childrenHeight;
		if ('childrenWidth' in $$props) childrenWidth = $$props.childrenWidth;
		if ('outerScale' in $$props) outerScale = $$props.outerScale;
		if ('width' in $$props) $$invalidate(7, width = $$props.width);
		if ('height' in $$props) $$invalidate(8, height = $$props.height);
		if ('combinedStyle' in $$props) $$invalidate(9, combinedStyle = $$props.combinedStyle);
		if ('box' in $$props) $$invalidate(10, box = $$props.box);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*data, style, scale*/ 14336) {
			{
				init();
				$$invalidate(7, width = calculateWidth());
				$$invalidate(8, height = calculateHeight());
				$$invalidate(9, combinedStyle = calculateStyle());
				$$invalidate(10, box = calculateBox());
			}
		}
	};

	return [
		className,
		spin,
		inverse,
		pulse,
		flip,
		label,
		self,
		width,
		height,
		combinedStyle,
		box,
		data,
		scale,
		style,
		slots,
		raw_data_binding,
		$$scope
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				class: 0,
				data: 11,
				scale: 12,
				spin: 1,
				inverse: 2,
				pulse: 3,
				flip: 4,
				label: 5,
				style: 13
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[11] === undefined && !('data' in props)) {
			console_1.warn("<Icon> was created without expected prop 'data'");
		}
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get data() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scale() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spin() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spin(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inverse() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inverse(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pulse() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pulse(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flip() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flip(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var search = { search: { width: 1664, height: 1792, paths: [{ d: 'M1152 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zM1664 1664q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z' }] } };

var bars = { bars: { width: 1536, height: 1792, paths: [{ d: 'M1536 1344v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zM1536 832v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zM1536 320v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45z' }] } };

var angleLeft = { 'angle-left': { width: 640, height: 1792, paths: [{ d: 'M627 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50 50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23 10l50 50q10 10 10 23z' }] } };

var angleRight = { 'angle-right': { width: 640, height: 1792, paths: [{ d: 'M595 960q0 13-10 23l-466 466q-10 10-23 10t-23-10l-50-50q-10-10-10-23t10-23l393-393-393-393q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l466 466q10 10 10 23z' }] } };

/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
var faFacebook = {
  prefix: 'fab',
  iconName: 'facebook',
  icon: [512, 512, [62000], "f09a", "M504 256C504 119 393 8 256 8S8 119 8 256c0 123.8 90.69 226.4 209.3 245V327.7h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.3 482.4 504 379.8 504 256z"]
};
var faInstagram = {
  prefix: 'fab',
  iconName: 'instagram',
  icon: [448, 512, [], "f16d", "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"]
};
var faTiktok = {
  prefix: 'fab',
  iconName: 'tiktok',
  icon: [448, 512, [], "e07b", "M448 209.9a210.1 210.1 0 0 1 -122.8-39.25V349.4A162.6 162.6 0 1 1 185 188.3V278.2a74.62 74.62 0 1 0 52.23 71.18V0l88 0a121.2 121.2 0 0 0 1.86 22.17h0A122.2 122.2 0 0 0 381 102.4a121.4 121.4 0 0 0 67 20.14z"]
};
var faTwitter = {
  prefix: 'fab',
  iconName: 'twitter',
  icon: [512, 512, [], "f099", "M459.4 151.7c.325 4.548 .325 9.097 .325 13.65 0 138.7-105.6 298.6-298.6 298.6-59.45 0-114.7-17.22-161.1-47.11 8.447 .974 16.57 1.299 25.34 1.299 49.06 0 94.21-16.57 130.3-44.83-46.13-.975-84.79-31.19-98.11-72.77 6.498 .974 12.99 1.624 19.82 1.624 9.421 0 18.84-1.3 27.61-3.573-48.08-9.747-84.14-51.98-84.14-102.1v-1.299c13.97 7.797 30.21 12.67 47.43 13.32-28.26-18.84-46.78-51.01-46.78-87.39 0-19.49 5.197-37.36 14.29-52.95 51.65 63.67 129.3 105.3 216.4 109.8-1.624-7.797-2.599-15.92-2.599-24.04 0-57.83 46.78-104.9 104.9-104.9 30.21 0 57.5 12.67 76.67 33.14 23.72-4.548 46.46-13.32 66.6-25.34-7.798 24.37-24.37 44.83-46.13 57.83 21.12-2.273 41.58-8.122 60.43-16.24-14.29 20.79-32.16 39.31-52.63 54.25z"]
};
var faYoutube = {
  prefix: 'fab',
  iconName: 'youtube',
  icon: [576, 512, [61802], "f167", "M549.7 124.1c-6.281-23.65-24.79-42.28-48.28-48.6C458.8 64 288 64 288 64S117.2 64 74.63 75.49c-23.5 6.322-42 24.95-48.28 48.6-11.41 42.87-11.41 132.3-11.41 132.3s0 89.44 11.41 132.3c6.281 23.65 24.79 41.5 48.28 47.82C117.2 448 288 448 288 448s170.8 0 213.4-11.49c23.5-6.321 42-24.17 48.28-47.82 11.41-42.87 11.41-132.3 11.41-132.3s0-89.44-11.41-132.3zm-317.5 213.5V175.2l142.7 81.21-142.7 81.2z"]
};

/* src\BurgerMenu.svelte generated by Svelte v3.46.4 */
const file$2 = "src\\BurgerMenu.svelte";

// (117:39) 
function create_if_block_2$1(ctx) {
	let section;
	let div0;
	let icon;
	let t0;
	let div3;
	let a0;
	let p0;
	let t2;
	let a1;
	let p1;
	let t4;
	let a2;
	let p2;
	let t6;
	let hr;
	let t7;
	let div2;
	let a3;
	let div1;
	let fa;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				data: angleLeft,
				style: "color:#fafafa",
				scale: 1.5
			},
			$$inline: true
		});

	fa = new Fa({
			props: { icon: faTwitter },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(icon.$$.fragment);
			t0 = space();
			div3 = element("div");
			a0 = element("a");
			p0 = element("p");
			p0.textContent = "Laporan";
			t2 = space();
			a1 = element("a");
			p1 = element("p");
			p1.textContent = "Tentang Kami";
			t4 = space();
			a2 = element("a");
			p2 = element("p");
			p2.textContent = "Redaksi";
			t6 = space();
			hr = element("hr");
			t7 = space();
			div2 = element("div");
			a3 = element("a");
			div1 = element("div");
			create_component(fa.$$.fragment);
			attr_dev(div0, "class", "close svelte-fk5ny2");
			set_style(div0, "cursor", "pointer");
			add_location(div0, file$2, 118, 8, 3759);
			attr_dev(p0, "class", "svelte-fk5ny2");
			add_location(p0, file$2, 131, 16, 4121);
			attr_dev(a0, "href", `/deduktif/`);
			attr_dev(a0, "class", "svelte-fk5ny2");
			add_location(a0, file$2, 130, 12, 4071);
			attr_dev(p1, "class", "svelte-fk5ny2");
			add_location(p1, file$2, 134, 16, 4222);
			attr_dev(a1, "href", `/deduktif/about`);
			attr_dev(a1, "class", "svelte-fk5ny2");
			add_location(a1, file$2, 133, 12, 4167);
			attr_dev(p2, "class", "svelte-fk5ny2");
			add_location(p2, file$2, 137, 16, 4330);
			attr_dev(a2, "href", `/deduktif/redaksi`);
			attr_dev(a2, "class", "svelte-fk5ny2");
			add_location(a2, file$2, 136, 12, 4273);
			attr_dev(hr, "class", "rounded svelte-fk5ny2");
			add_location(hr, file$2, 140, 12, 4378);
			attr_dev(div1, "class", "sm tw svelte-fk5ny2");
			add_location(div1, file$2, 144, 20, 4555);
			attr_dev(a3, "href", "https://twitter.com/deduktifid");
			attr_dev(a3, "class", "svelte-fk5ny2");
			add_location(a3, file$2, 143, 16, 4464);
			attr_dev(div2, "class", "sosmed svelte-fk5ny2");
			add_location(div2, file$2, 142, 12, 4426);
			attr_dev(div3, "class", "menu svelte-fk5ny2");
			add_location(div3, file$2, 129, 8, 4039);
			attr_dev(section, "class", "svelte-fk5ny2");
			add_location(section, file$2, 117, 4, 3740);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(icon, div0, null);
			append_dev(section, t0);
			append_dev(section, div3);
			append_dev(div3, a0);
			append_dev(a0, p0);
			append_dev(div3, t2);
			append_dev(div3, a1);
			append_dev(a1, p1);
			append_dev(div3, t4);
			append_dev(div3, a2);
			append_dev(a2, p2);
			append_dev(div3, t6);
			append_dev(div3, hr);
			append_dev(div3, t7);
			append_dev(div3, div2);
			append_dev(div2, a3);
			append_dev(a3, div1);
			mount_component(fa, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*burgerMenuOut*/ ctx[2], false, false, false),
					action_destroyer(link.call(null, a0)),
					action_destroyer(link.call(null, a1)),
					action_destroyer(link.call(null, a2))
				];

				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(fa.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(fa.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(icon);
			destroy_component(fa);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(117:39) ",
		ctx
	});

	return block;
}

// (83:33) 
function create_if_block_1$1(ctx) {
	let section;
	let div0;
	let icon;
	let t0;
	let div3;
	let a0;
	let p0;
	let t2;
	let a1;
	let p1;
	let t4;
	let a2;
	let p2;
	let t6;
	let hr;
	let t7;
	let div2;
	let a3;
	let div1;
	let fa;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				data: angleLeft,
				style: "color:#fafafa",
				scale: 1.5
			},
			$$inline: true
		});

	fa = new Fa({
			props: { icon: faTwitter },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(icon.$$.fragment);
			t0 = space();
			div3 = element("div");
			a0 = element("a");
			p0 = element("p");
			p0.textContent = "Laporan";
			t2 = space();
			a1 = element("a");
			p1 = element("p");
			p1.textContent = "Tentang Kami";
			t4 = space();
			a2 = element("a");
			p2 = element("p");
			p2.textContent = "Redaksi";
			t6 = space();
			hr = element("hr");
			t7 = space();
			div2 = element("div");
			a3 = element("a");
			div1 = element("div");
			create_component(fa.$$.fragment);
			attr_dev(div0, "class", "close svelte-fk5ny2");
			add_location(div0, file$2, 84, 8, 2763);
			attr_dev(p0, "class", "svelte-fk5ny2");
			add_location(p0, file$2, 96, 16, 3089);
			attr_dev(a0, "href", `/deduktif/`);
			attr_dev(a0, "class", "svelte-fk5ny2");
			add_location(a0, file$2, 95, 12, 3039);
			attr_dev(p1, "class", "svelte-fk5ny2");
			add_location(p1, file$2, 99, 16, 3190);
			attr_dev(a1, "href", `/deduktif/about`);
			attr_dev(a1, "class", "svelte-fk5ny2");
			add_location(a1, file$2, 98, 12, 3135);
			attr_dev(p2, "class", "svelte-fk5ny2");
			add_location(p2, file$2, 102, 16, 3298);
			attr_dev(a2, "href", `/deduktif/redaksi`);
			attr_dev(a2, "class", "svelte-fk5ny2");
			add_location(a2, file$2, 101, 12, 3241);
			attr_dev(hr, "class", "rounded svelte-fk5ny2");
			add_location(hr, file$2, 105, 12, 3346);
			attr_dev(div1, "class", "sm tw svelte-fk5ny2");
			add_location(div1, file$2, 109, 20, 3523);
			attr_dev(a3, "href", "https://twitter.com/deduktifid");
			attr_dev(a3, "class", "svelte-fk5ny2");
			add_location(a3, file$2, 108, 16, 3432);
			attr_dev(div2, "class", "sosmed svelte-fk5ny2");
			add_location(div2, file$2, 107, 12, 3394);
			attr_dev(div3, "class", "menu svelte-fk5ny2");
			add_location(div3, file$2, 94, 8, 3007);
			attr_dev(section, "class", "svelte-fk5ny2");
			add_location(section, file$2, 83, 4, 2744);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(icon, div0, null);
			append_dev(section, t0);
			append_dev(section, div3);
			append_dev(div3, a0);
			append_dev(a0, p0);
			append_dev(div3, t2);
			append_dev(div3, a1);
			append_dev(a1, p1);
			append_dev(div3, t4);
			append_dev(div3, a2);
			append_dev(a2, p2);
			append_dev(div3, t6);
			append_dev(div3, hr);
			append_dev(div3, t7);
			append_dev(div3, div2);
			append_dev(div2, a3);
			append_dev(a3, div1);
			mount_component(fa, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*burgerMenuOut*/ ctx[2], false, false, false),
					action_destroyer(link.call(null, a0)),
					action_destroyer(link.call(null, a1)),
					action_destroyer(link.call(null, a2))
				];

				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(fa.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(fa.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(icon);
			destroy_component(fa);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(83:33) ",
		ctx
	});

	return block;
}

// (17:4) {#if page == 'indeks'}
function create_if_block$1(ctx) {
	let section;
	let div0;
	let icon;
	let t0;
	let div7;
	let a0;
	let p0;
	let t2;
	let a1;
	let p1;
	let t4;
	let a2;
	let p2;
	let t6;
	let hr0;
	let t7;
	let a3;
	let p3;
	let t9;
	let a4;
	let p4;
	let t11;
	let a5;
	let p5;
	let t13;
	let hr1;
	let t14;
	let div6;
	let a6;
	let div1;
	let fa0;
	let t15;
	let a7;
	let div2;
	let fa1;
	let t16;
	let a8;
	let div3;
	let fa2;
	let t17;
	let a9;
	let div4;
	let fa3;
	let t18;
	let a10;
	let div5;
	let fa4;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				data: angleLeft,
				style: "color:#fafafa",
				scale: 1.5
			},
			$$inline: true
		});

	fa0 = new Fa({
			props: { icon: faInstagram },
			$$inline: true
		});

	fa1 = new Fa({
			props: { icon: faFacebook },
			$$inline: true
		});

	fa2 = new Fa({
			props: { icon: faTwitter },
			$$inline: true
		});

	fa3 = new Fa({
			props: { icon: faYoutube },
			$$inline: true
		});

	fa4 = new Fa({
			props: { icon: faTiktok },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(icon.$$.fragment);
			t0 = space();
			div7 = element("div");
			a0 = element("a");
			p0 = element("p");
			p0.textContent = "Tentang Kami";
			t2 = space();
			a1 = element("a");
			p1 = element("p");
			p1.textContent = "Redaksi";
			t4 = space();
			a2 = element("a");
			p2 = element("p");
			p2.textContent = "Klub Sosial Jurno";
			t6 = space();
			hr0 = element("hr");
			t7 = space();
			a3 = element("a");
			p3 = element("p");
			p3.textContent = "Jurno Original";
			t9 = space();
			a4 = element("a");
			p4 = element("p");
			p4.textContent = "Deduktif";
			t11 = space();
			a5 = element("a");
			p5 = element("p");
			p5.textContent = "Paralaks";
			t13 = space();
			hr1 = element("hr");
			t14 = space();
			div6 = element("div");
			a6 = element("a");
			div1 = element("div");
			create_component(fa0.$$.fragment);
			t15 = space();
			a7 = element("a");
			div2 = element("div");
			create_component(fa1.$$.fragment);
			t16 = space();
			a8 = element("a");
			div3 = element("div");
			create_component(fa2.$$.fragment);
			t17 = space();
			a9 = element("a");
			div4 = element("div");
			create_component(fa3.$$.fragment);
			t18 = space();
			a10 = element("a");
			div5 = element("div");
			create_component(fa4.$$.fragment);
			attr_dev(div0, "class", "close svelte-fk5ny2");
			add_location(div0, file$2, 18, 8, 539);
			attr_dev(p0, "class", "svelte-fk5ny2");
			add_location(p0, file$2, 30, 16, 862);
			attr_dev(a0, "href", `/about/`);
			attr_dev(a0, "class", "svelte-fk5ny2");
			add_location(a0, file$2, 29, 12, 815);
			attr_dev(p1, "class", "svelte-fk5ny2");
			add_location(p1, file$2, 33, 16, 962);
			attr_dev(a1, "href", `/redaksi/`);
			attr_dev(a1, "class", "svelte-fk5ny2");
			add_location(a1, file$2, 32, 12, 913);
			attr_dev(p2, "class", "svelte-fk5ny2");
			add_location(p2, file$2, 36, 16, 1064);
			attr_dev(a2, "href", "");
			attr_dev(a2, "class", "svelte-fk5ny2");
			add_location(a2, file$2, 35, 12, 1008);
			attr_dev(hr0, "class", "rounded svelte-fk5ny2");
			add_location(hr0, file$2, 39, 12, 1122);
			attr_dev(p3, "class", "svelte-fk5ny2");
			add_location(p3, file$2, 42, 16, 1207);
			attr_dev(a3, "href", `/article/`);
			attr_dev(a3, "class", "svelte-fk5ny2");
			add_location(a3, file$2, 41, 12, 1158);
			attr_dev(p4, "class", "svelte-fk5ny2");
			add_location(p4, file$2, 45, 16, 1310);
			attr_dev(a4, "href", `/deduktif/`);
			attr_dev(a4, "class", "svelte-fk5ny2");
			add_location(a4, file$2, 44, 12, 1260);
			attr_dev(p5, "class", "svelte-fk5ny2");
			add_location(p5, file$2, 48, 16, 1407);
			attr_dev(a5, "href", `/paralaks/`);
			attr_dev(a5, "class", "svelte-fk5ny2");
			add_location(a5, file$2, 47, 12, 1357);
			attr_dev(hr1, "class", "rounded svelte-fk5ny2");
			add_location(hr1, file$2, 51, 12, 1456);
			attr_dev(div1, "class", "sm ig svelte-fk5ny2");
			add_location(div1, file$2, 55, 20, 1638);
			attr_dev(a6, "href", "https://www.instagram.com/jurnoid/");
			attr_dev(a6, "class", "svelte-fk5ny2");
			add_location(a6, file$2, 54, 16, 1542);
			attr_dev(div2, "class", "sm fb svelte-fk5ny2");
			add_location(div2, file$2, 60, 20, 1837);
			attr_dev(a7, "href", "");
			attr_dev(a7, "class", "svelte-fk5ny2");
			add_location(a7, file$2, 59, 16, 1776);
			attr_dev(div3, "class", "sm tw svelte-fk5ny2");
			add_location(div3, file$2, 65, 20, 2063);
			attr_dev(a8, "href", "https://twitter.com/jurno_id");
			attr_dev(a8, "class", "svelte-fk5ny2");
			add_location(a8, file$2, 64, 16, 1974);
			attr_dev(div4, "class", "sm yt svelte-fk5ny2");
			add_location(div4, file$2, 70, 20, 2315);
			attr_dev(a9, "href", "https://www.youtube.com/channel/UCSGTUIGbrpONOTayMXAIcqw");
			attr_dev(a9, "class", "svelte-fk5ny2");
			add_location(a9, file$2, 69, 16, 2199);
			attr_dev(div5, "class", "sm tt svelte-fk5ny2");
			add_location(div5, file$2, 75, 20, 2533);
			attr_dev(a10, "href", "www.tiktok.com/@jurnoid");
			attr_dev(a10, "class", "svelte-fk5ny2");
			add_location(a10, file$2, 74, 16, 2451);
			attr_dev(div6, "class", "sosmed svelte-fk5ny2");
			add_location(div6, file$2, 53, 12, 1504);
			attr_dev(div7, "class", "menu svelte-fk5ny2");
			add_location(div7, file$2, 28, 8, 783);
			attr_dev(section, "class", "svelte-fk5ny2");
			add_location(section, file$2, 17, 4, 520);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(icon, div0, null);
			append_dev(section, t0);
			append_dev(section, div7);
			append_dev(div7, a0);
			append_dev(a0, p0);
			append_dev(div7, t2);
			append_dev(div7, a1);
			append_dev(a1, p1);
			append_dev(div7, t4);
			append_dev(div7, a2);
			append_dev(a2, p2);
			append_dev(div7, t6);
			append_dev(div7, hr0);
			append_dev(div7, t7);
			append_dev(div7, a3);
			append_dev(a3, p3);
			append_dev(div7, t9);
			append_dev(div7, a4);
			append_dev(a4, p4);
			append_dev(div7, t11);
			append_dev(div7, a5);
			append_dev(a5, p5);
			append_dev(div7, t13);
			append_dev(div7, hr1);
			append_dev(div7, t14);
			append_dev(div7, div6);
			append_dev(div6, a6);
			append_dev(a6, div1);
			mount_component(fa0, div1, null);
			append_dev(div6, t15);
			append_dev(div6, a7);
			append_dev(a7, div2);
			mount_component(fa1, div2, null);
			append_dev(div6, t16);
			append_dev(div6, a8);
			append_dev(a8, div3);
			mount_component(fa2, div3, null);
			append_dev(div6, t17);
			append_dev(div6, a9);
			append_dev(a9, div4);
			mount_component(fa3, div4, null);
			append_dev(div6, t18);
			append_dev(div6, a10);
			append_dev(a10, div5);
			mount_component(fa4, div5, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*burgerMenuOut*/ ctx[2], false, false, false),
					action_destroyer(link.call(null, a0)),
					action_destroyer(link.call(null, a1)),
					action_destroyer(link.call(null, a3)),
					action_destroyer(link.call(null, a4)),
					action_destroyer(link.call(null, a5))
				];

				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(fa0.$$.fragment, local);
			transition_in(fa1.$$.fragment, local);
			transition_in(fa2.$$.fragment, local);
			transition_in(fa3.$$.fragment, local);
			transition_in(fa4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(fa0.$$.fragment, local);
			transition_out(fa1.$$.fragment, local);
			transition_out(fa2.$$.fragment, local);
			transition_out(fa3.$$.fragment, local);
			transition_out(fa4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(icon);
			destroy_component(fa0);
			destroy_component(fa1);
			destroy_component(fa2);
			destroy_component(fa3);
			destroy_component(fa4);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(17:4) {#if page == 'indeks'}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let nav;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_1$1, create_if_block_2$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*page*/ ctx[1] == 'indeks') return 0;
		if (/*page*/ ctx[1] == 'deduktif') return 1;
		if (/*page*/ ctx[1] == 'indeksdeduktif') return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			nav = element("nav");
			if (if_block) if_block.c();
			set_style(nav, "left", /*burgerIn*/ ctx[0] ? '0px' : '-160px');
			attr_dev(nav, "class", "svelte-fk5ny2");
			add_location(nav, file$2, 15, 0, 437);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(nav, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(nav, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*burgerIn*/ 1) {
				set_style(nav, "left", /*burgerIn*/ ctx[0] ? '0px' : '-160px');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BurgerMenu', slots, []);
	let { burgerIn = false } = $$props;
	let { page } = $$props;

	const burgerMenuOut = () => {
		$$invalidate(0, burgerIn = false);
	};

	const writable_props = ['burgerIn', 'page'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BurgerMenu> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('burgerIn' in $$props) $$invalidate(0, burgerIn = $$props.burgerIn);
		if ('page' in $$props) $$invalidate(1, page = $$props.page);
	};

	$$self.$capture_state = () => ({
		Icon,
		angleLeft,
		Fa,
		faTiktok,
		faInstagram,
		faTwitter,
		faFacebook,
		faYoutube,
		link,
		burgerIn,
		page,
		burgerMenuOut
	});

	$$self.$inject_state = $$props => {
		if ('burgerIn' in $$props) $$invalidate(0, burgerIn = $$props.burgerIn);
		if ('page' in $$props) $$invalidate(1, page = $$props.page);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [burgerIn, page, burgerMenuOut];
}

class BurgerMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { burgerIn: 0, page: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BurgerMenu",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*page*/ ctx[1] === undefined && !('page' in props)) {
			console.warn("<BurgerMenu> was created without expected prop 'page'");
		}
	}

	get burgerIn() {
		throw new Error("<BurgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set burgerIn(value) {
		throw new Error("<BurgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get page() {
		throw new Error("<BurgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set page(value) {
		throw new Error("<BurgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Search.svelte generated by Svelte v3.46.4 */
const file$1 = "src\\Search.svelte";

function create_fragment$1(ctx) {
	let nav;
	let section;
	let form;
	let input;
	let t0;
	let button;
	let form_action_value;
	let t2;
	let div;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				data: angleRight,
				style: "color:#fafafa",
				scale: 1.5
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			section = element("section");
			form = element("form");
			input = element("input");
			t0 = space();
			button = element("button");
			button.textContent = "Search";
			t2 = space();
			div = element("div");
			create_component(icon.$$.fragment);
			attr_dev(input, "type", "search");
			attr_dev(input, "placeholder", "Cari Artikel...");
			attr_dev(input, "class", "svelte-1nnjpi");
			add_location(input, file$1, 18, 12, 487);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "svelte-1nnjpi");
			add_location(button, file$1, 19, 12, 578);
			attr_dev(form, "action", form_action_value = "/#/search?keywords=" + /*searchValue*/ ctx[1]);
			attr_dev(form, "class", "svelte-1nnjpi");
			add_location(form, file$1, 17, 8, 425);
			attr_dev(div, "class", "close svelte-1nnjpi");
			add_location(div, file$1, 21, 8, 642);
			attr_dev(section, "class", "svelte-1nnjpi");
			add_location(section, file$1, 16, 4, 406);
			set_style(nav, "right", /*searchIn*/ ctx[0] ? '0px' : '-100vw');
			attr_dev(nav, "class", "svelte-1nnjpi");
			add_location(nav, file$1, 15, 0, 350);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, section);
			append_dev(section, form);
			append_dev(form, input);
			set_input_value(input, /*searchValue*/ ctx[1]);
			append_dev(form, t0);
			append_dev(form, button);
			append_dev(section, t2);
			append_dev(section, div);
			mount_component(icon, div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[3]),
					listen_dev(div, "click", /*searchOut*/ ctx[2], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*searchValue*/ 2) {
				set_input_value(input, /*searchValue*/ ctx[1]);
			}

			if (!current || dirty & /*searchValue*/ 2 && form_action_value !== (form_action_value = "/#/search?keywords=" + /*searchValue*/ ctx[1])) {
				attr_dev(form, "action", form_action_value);
			}

			if (!current || dirty & /*searchIn*/ 1) {
				set_style(nav, "right", /*searchIn*/ ctx[0] ? '0px' : '-100vw');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(icon);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Search', slots, []);
	let { searchIn = false } = $$props;
	let { searchValue } = $$props;

	const searchOut = () => {
		$$invalidate(0, searchIn = false);
	};

	const writable_props = ['searchIn', 'searchValue'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Search> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		searchValue = this.value;
		$$invalidate(1, searchValue);
	}

	$$self.$$set = $$props => {
		if ('searchIn' in $$props) $$invalidate(0, searchIn = $$props.searchIn);
		if ('searchValue' in $$props) $$invalidate(1, searchValue = $$props.searchValue);
	};

	$$self.$capture_state = () => ({
		Icon,
		angleRight,
		link,
		createEventDispatcher,
		searchIn,
		searchValue,
		searchOut
	});

	$$self.$inject_state = $$props => {
		if ('searchIn' in $$props) $$invalidate(0, searchIn = $$props.searchIn);
		if ('searchValue' in $$props) $$invalidate(1, searchValue = $$props.searchValue);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [searchIn, searchValue, searchOut, input_input_handler];
}

class Search extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { searchIn: 0, searchValue: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Search",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*searchValue*/ ctx[1] === undefined && !('searchValue' in props)) {
			console.warn("<Search> was created without expected prop 'searchValue'");
		}
	}

	get searchIn() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchIn(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchValue() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchValue(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Head.svelte generated by Svelte v3.46.4 */
const file = "src\\Head.svelte";

// (39:4) {#if page == 'artikel' || 'indeks'}
function create_if_block_2(ctx) {
	let div1;
	let div0;
	let t;
	let div1_resize_listener;
	let current;
	let if_block0 = /*page*/ ctx[1] == 'artikel' && create_if_block_4(ctx);
	let if_block1 = /*page*/ ctx[1] == 'indeks' && create_if_block_3(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(div0, "class", "header-logo svelte-ygpo80");

			set_style(div0, "justify-content", /*page*/ ctx[1] == 'artikel'
			? 'flex-start'
			: 'space-between');

			add_location(div0, file, 40, 12, 1271);
			attr_dev(div1, "class", "container svelte-ygpo80");
			set_style(div1, "background-color", "#fafafa}");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[14].call(div1));
			add_location(div1, file, 39, 8, 1173);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t);
			if (if_block1) if_block1.m(div0, null);
			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[14].bind(div1));
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*page*/ ctx[1] == 'artikel') {
				if (if_block0) ; else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div0, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*page*/ ctx[1] == 'indeks') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*page*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*page*/ 2) {
				set_style(div0, "justify-content", /*page*/ ctx[1] == 'artikel'
				? 'flex-start'
				: 'space-between');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			div1_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(39:4) {#if page == 'artikel' || 'indeks'}",
		ctx
	});

	return block;
}

// (42:16) {#if page == 'artikel'}
function create_if_block_4(ctx) {
	let a;
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = "./images/logo-jurno-web.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "Logo Jurno Website");
			attr_dev(img, "class", "svelte-ygpo80");
			add_location(img, file, 43, 24, 1473);
			attr_dev(a, "href", "/");
			attr_dev(a, "class", "svelte-ygpo80");
			add_location(a, file, 42, 20, 1435);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(42:16) {#if page == 'artikel'}",
		ctx
	});

	return block;
}

// (47:16) {#if page == 'indeks'}
function create_if_block_3(ctx) {
	let div0;
	let icon0;
	let t0;
	let a;
	let img;
	let img_src_value;
	let t1;
	let div1;
	let icon1;
	let current;
	let mounted;
	let dispose;
	icon0 = new Icon({ props: { data: bars }, $$inline: true });
	icon1 = new Icon({ props: { data: search }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(icon0.$$.fragment);
			t0 = space();
			a = element("a");
			img = element("img");
			t1 = space();
			div1 = element("div");
			create_component(icon1.$$.fragment);
			attr_dev(div0, "class", "before");
			set_style(div0, "cursor", "pointer");
			add_location(div0, file, 47, 20, 1648);
			if (!src_url_equal(img.src, img_src_value = "./images/logo-jurno-web.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "Logo Jurno Website");
			attr_dev(img, "class", "svelte-ygpo80");
			add_location(img, file, 51, 24, 1859);
			attr_dev(a, "href", "/");
			attr_dev(a, "class", "svelte-ygpo80");
			add_location(a, file, 50, 20, 1821);
			attr_dev(div1, "class", "after");
			set_style(div1, "cursor", "pointer");
			add_location(div1, file, 53, 20, 1971);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(icon0, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, a, anchor);
			append_dev(a, img);
			insert_dev(target, t1, anchor);
			insert_dev(target, div1, anchor);
			mount_component(icon1, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler*/ ctx[12], false, false, false),
					listen_dev(div1, "click", /*click_handler_1*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(icon0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(a);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div1);
			destroy_component(icon1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(47:16) {#if page == 'indeks'}",
		ctx
	});

	return block;
}

// (62:4) {#if page == 'deduktif' }
function create_if_block_1(ctx) {
	let div4;
	let div0;
	let a0;
	let img;
	let img_src_value;
	let t0;
	let div3;
	let a1;
	let t2;
	let div1;
	let t3;
	let a2;
	let t5;
	let div2;
	let t6;
	let a3;
	let div4_resize_listener;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			a0 = element("a");
			img = element("img");
			t0 = space();
			div3 = element("div");
			a1 = element("a");
			a1.textContent = "Laporan";
			t2 = space();
			div1 = element("div");
			t3 = space();
			a2 = element("a");
			a2.textContent = "Tentang Kami";
			t5 = space();
			div2 = element("div");
			t6 = space();
			a3 = element("a");
			a3.textContent = "Redaksi";
			if (!src_url_equal(img.src, img_src_value = "./images/deduktif.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "Logo Deduktif Website");
			set_style(img, "filter", "invert(54%) sepia(65%) saturate(1029%) hue-rotate(318deg) brightness(87%) contrast(114%)");
			attr_dev(img, "class", "svelte-ygpo80");
			add_location(img, file, 70, 20, 2593);
			attr_dev(a0, "href", "/");
			attr_dev(a0, "class", "svelte-ygpo80");
			add_location(a0, file, 69, 16, 2559);
			attr_dev(div0, "class", "deduktif-logo");
			set_style(div0, "margin-left", "6%");
			add_location(div0, file, 68, 12, 2491);
			attr_dev(a1, "href", "/deduktif/");
			attr_dev(a1, "class", "svelte-ygpo80");
			add_location(a1, file, 75, 16, 2906);
			attr_dev(div1, "class", "vert svelte-ygpo80");
			add_location(div1, file, 78, 16, 3005);
			attr_dev(a2, "href", "/deduktif/about/");
			attr_dev(a2, "class", "svelte-ygpo80");
			add_location(a2, file, 79, 16, 3047);
			attr_dev(div2, "class", "vert svelte-ygpo80");
			add_location(div2, file, 82, 16, 3157);
			attr_dev(a3, "href", "/deduktif/redaksi/");
			attr_dev(a3, "class", "svelte-ygpo80");
			add_location(a3, file, 83, 16, 3199);
			attr_dev(div3, "class", "deduktif-menu svelte-ygpo80");
			set_style(div3, "margin-right", "6%");
			add_location(div3, file, 74, 12, 2837);
			attr_dev(div4, "class", "container svelte-ygpo80");
			set_style(div4, "background-color", "#050505");
			set_style(div4, "display", "flex");
			set_style(div4, "justify-content", "space-between");
			set_style(div4, "flex-direction", "row");
			add_render_callback(() => /*div4_elementresize_handler*/ ctx[15].call(div4));
			add_location(div4, file, 62, 8, 2252);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div0, a0);
			append_dev(a0, img);
			append_dev(div4, t0);
			append_dev(div4, div3);
			append_dev(div3, a1);
			append_dev(div3, t2);
			append_dev(div3, div1);
			append_dev(div3, t3);
			append_dev(div3, a2);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div3, t6);
			append_dev(div3, a3);
			div4_resize_listener = add_resize_listener(div4, /*div4_elementresize_handler*/ ctx[15].bind(div4));

			if (!mounted) {
				dispose = [
					action_destroyer(link.call(null, a1)),
					action_destroyer(link.call(null, a2)),
					action_destroyer(link.call(null, a3))
				];

				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			div4_resize_listener();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(62:4) {#if page == 'deduktif' }",
		ctx
	});

	return block;
}

// (90:4) {#if page == 'indeksdeduktif'}
function create_if_block(ctx) {
	let div3;
	let div2;
	let div0;
	let icon0;
	let t0;
	let a;
	let img;
	let img_src_value;
	let t1;
	let div1;
	let icon1;
	let div3_resize_listener;
	let current;
	let mounted;
	let dispose;

	icon0 = new Icon({
			props: { data: bars, style: "color:#fafafa" },
			$$inline: true
		});

	icon1 = new Icon({
			props: { data: search, style: "color:#fafafa" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			create_component(icon0.$$.fragment);
			t0 = space();
			a = element("a");
			img = element("img");
			t1 = space();
			div1 = element("div");
			create_component(icon1.$$.fragment);
			attr_dev(div0, "class", "before");
			set_style(div0, "cursor", "pointer");
			add_location(div0, file, 92, 20, 3601);
			if (!src_url_equal(img.src, img_src_value = "./images/deduktif.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "Logo Deduktif Website");
			set_style(img, "filter", "invert(54%) sepia(65%) saturate(1029%) hue-rotate(318deg) brightness(87%) contrast(114%)");
			attr_dev(img, "class", "svelte-ygpo80");
			add_location(img, file, 96, 24, 3833);
			attr_dev(a, "href", "/");
			attr_dev(a, "class", "svelte-ygpo80");
			add_location(a, file, 95, 20, 3795);
			attr_dev(div1, "class", "after");
			set_style(div1, "cursor", "pointer");
			add_location(div1, file, 99, 20, 4069);
			attr_dev(div2, "class", "header-logo svelte-ygpo80");

			set_style(div2, "justify-content", /*page*/ ctx[1] == 'artikel'
			? 'flex-start'
			: 'space-between');

			add_location(div2, file, 91, 12, 3478);
			attr_dev(div3, "class", "container svelte-ygpo80");
			set_style(div3, "background-color", "#050505");
			add_render_callback(() => /*div3_elementresize_handler*/ ctx[18].call(div3));
			add_location(div3, file, 90, 8, 3381);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);
			mount_component(icon0, div0, null);
			append_dev(div2, t0);
			append_dev(div2, a);
			append_dev(a, img);
			append_dev(div2, t1);
			append_dev(div2, div1);
			mount_component(icon1, div1, null);
			div3_resize_listener = add_resize_listener(div3, /*div3_elementresize_handler*/ ctx[18].bind(div3));
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler_2*/ ctx[16], false, false, false),
					listen_dev(div1, "click", /*click_handler_3*/ ctx[17], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*page*/ 2) {
				set_style(div2, "justify-content", /*page*/ ctx[1] == 'artikel'
				? 'flex-start'
				: 'space-between');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(icon0);
			destroy_component(icon1);
			div3_resize_listener();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(90:4) {#if page == 'indeksdeduktif'}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let burgermenu;
	let div;
	let updating_burgerIn;
	let updating_page;
	let t0;
	let search_1;
	let div_1;
	let updating_searchIn;
	let updating_searchValue;
	let t1;
	let nav;
	let t2;
	let t3;
	let current;

	function burgermenu_burgerIn_binding(value) {
		/*burgermenu_burgerIn_binding*/ ctx[8](value);
	}

	function burgermenu_page_binding(value) {
		/*burgermenu_page_binding*/ ctx[9](value);
	}

	let burgermenu_props = {};

	if (/*burgerIn*/ ctx[2] !== void 0) {
		burgermenu_props.burgerIn = /*burgerIn*/ ctx[2];
	}

	if (/*page*/ ctx[1] !== void 0) {
		burgermenu_props.page = /*page*/ ctx[1];
	}

	burgermenu = new BurgerMenu({ props: burgermenu_props, $$inline: true });
	binding_callbacks.push(() => bind(burgermenu, 'burgerIn', burgermenu_burgerIn_binding));
	binding_callbacks.push(() => bind(burgermenu, 'page', burgermenu_page_binding));

	function search_1_searchIn_binding(value) {
		/*search_1_searchIn_binding*/ ctx[10](value);
	}

	function search_1_searchValue_binding(value) {
		/*search_1_searchValue_binding*/ ctx[11](value);
	}

	let search_1_props = {};

	if (/*searchIn*/ ctx[3] !== void 0) {
		search_1_props.searchIn = /*searchIn*/ ctx[3];
	}

	if (/*searchValue*/ ctx[4] !== void 0) {
		search_1_props.searchValue = /*searchValue*/ ctx[4];
	}

	search_1 = new Search({ props: search_1_props, $$inline: true });
	binding_callbacks.push(() => bind(search_1, 'searchIn', search_1_searchIn_binding));
	binding_callbacks.push(() => bind(search_1, 'searchValue', search_1_searchValue_binding));
	let if_block0 = (/*page*/ ctx[1] == 'artikel' || 'indeks') && create_if_block_2(ctx);
	let if_block1 = /*page*/ ctx[1] == 'deduktif' && create_if_block_1(ctx);
	let if_block2 = /*page*/ ctx[1] == 'indeksdeduktif' && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(burgermenu.$$.fragment);
			t0 = space();
			div_1 = element("div");
			create_component(search_1.$$.fragment);
			t1 = space();
			nav = element("nav");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			set_style(div, "display", "contents");
			set_style(div, "--color-brand-dark-blue", /*colorBrandDarkBlue*/ ctx[7]);
			set_style(div, "--color-brand-white", /*colorBrandWhite*/ ctx[5]);
			set_style(div, "--color-brand-red", /*colorBrandRed*/ ctx[6]);
			set_style(div_1, "display", "contents");
			set_style(div_1, "--color-brand-red", /*colorBrandRed*/ ctx[6]);
			attr_dev(nav, "class", "svelte-ygpo80");
			add_location(nav, file, 37, 0, 1117);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(burgermenu, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, div_1, anchor);
			mount_component(search_1, div_1, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, nav, anchor);
			if (if_block0) if_block0.m(nav, null);
			append_dev(nav, t2);
			if (if_block1) if_block1.m(nav, null);
			append_dev(nav, t3);
			if (if_block2) if_block2.m(nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const burgermenu_changes = {};

			if (!updating_burgerIn && dirty & /*burgerIn*/ 4) {
				updating_burgerIn = true;
				burgermenu_changes.burgerIn = /*burgerIn*/ ctx[2];
				add_flush_callback(() => updating_burgerIn = false);
			}

			if (!updating_page && dirty & /*page*/ 2) {
				updating_page = true;
				burgermenu_changes.page = /*page*/ ctx[1];
				add_flush_callback(() => updating_page = false);
			}

			burgermenu.$set(burgermenu_changes);
			const search_1_changes = {};

			if (!updating_searchIn && dirty & /*searchIn*/ 8) {
				updating_searchIn = true;
				search_1_changes.searchIn = /*searchIn*/ ctx[3];
				add_flush_callback(() => updating_searchIn = false);
			}

			if (!updating_searchValue && dirty & /*searchValue*/ 16) {
				updating_searchValue = true;
				search_1_changes.searchValue = /*searchValue*/ ctx[4];
				add_flush_callback(() => updating_searchValue = false);
			}

			search_1.$set(search_1_changes);

			if (/*page*/ ctx[1] == 'artikel' || 'indeks') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*page*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(nav, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*page*/ ctx[1] == 'deduktif') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(nav, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*page*/ ctx[1] == 'indeksdeduktif') {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*page*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(nav, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(burgermenu.$$.fragment, local);
			transition_in(search_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(burgermenu.$$.fragment, local);
			transition_out(search_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(burgermenu, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div_1);
			destroy_component(search_1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(nav);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Head', slots, []);
	const dispatch = createEventDispatcher();
	let { height } = $$props;
	let { page } = $$props;
	let { burgerIn, searchIn, searchValue } = $$props;

	let colorBrandWhite = "#fafafa",
		colorBrandRed = "#ef5959",
		colorBrandDarkBlue = "#242053",
		colorBrandBlue = "#A4D9D2";

	const writable_props = ['height', 'page', 'burgerIn', 'searchIn', 'searchValue'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Head> was created with unknown prop '${key}'`);
	});

	function burgermenu_burgerIn_binding(value) {
		burgerIn = value;
		$$invalidate(2, burgerIn);
	}

	function burgermenu_page_binding(value) {
		page = value;
		$$invalidate(1, page);
	}

	function search_1_searchIn_binding(value) {
		searchIn = value;
		$$invalidate(3, searchIn);
	}

	function search_1_searchValue_binding(value) {
		searchValue = value;
		$$invalidate(4, searchValue);
	}

	const click_handler = () => {
		$$invalidate(2, burgerIn = true);
	};

	const click_handler_1 = () => {
		$$invalidate(3, searchIn = true);
	};

	function div1_elementresize_handler() {
		height = this.clientHeight;
		$$invalidate(0, height);
	}

	function div4_elementresize_handler() {
		height = this.clientHeight;
		$$invalidate(0, height);
	}

	const click_handler_2 = () => {
		$$invalidate(2, burgerIn = true);
	};

	const click_handler_3 = () => {
		$$invalidate(3, searchIn = true);
	};

	function div3_elementresize_handler() {
		height = this.clientHeight;
		$$invalidate(0, height);
	}

	$$self.$$set = $$props => {
		if ('height' in $$props) $$invalidate(0, height = $$props.height);
		if ('page' in $$props) $$invalidate(1, page = $$props.page);
		if ('burgerIn' in $$props) $$invalidate(2, burgerIn = $$props.burgerIn);
		if ('searchIn' in $$props) $$invalidate(3, searchIn = $$props.searchIn);
		if ('searchValue' in $$props) $$invalidate(4, searchValue = $$props.searchValue);
	};

	$$self.$capture_state = () => ({
		Icon,
		search,
		bars,
		createEventDispatcher,
		BurgerMenu,
		Search,
		link,
		dispatch,
		height,
		page,
		burgerIn,
		searchIn,
		searchValue,
		colorBrandWhite,
		colorBrandRed,
		colorBrandDarkBlue,
		colorBrandBlue
	});

	$$self.$inject_state = $$props => {
		if ('height' in $$props) $$invalidate(0, height = $$props.height);
		if ('page' in $$props) $$invalidate(1, page = $$props.page);
		if ('burgerIn' in $$props) $$invalidate(2, burgerIn = $$props.burgerIn);
		if ('searchIn' in $$props) $$invalidate(3, searchIn = $$props.searchIn);
		if ('searchValue' in $$props) $$invalidate(4, searchValue = $$props.searchValue);
		if ('colorBrandWhite' in $$props) $$invalidate(5, colorBrandWhite = $$props.colorBrandWhite);
		if ('colorBrandRed' in $$props) $$invalidate(6, colorBrandRed = $$props.colorBrandRed);
		if ('colorBrandDarkBlue' in $$props) $$invalidate(7, colorBrandDarkBlue = $$props.colorBrandDarkBlue);
		if ('colorBrandBlue' in $$props) colorBrandBlue = $$props.colorBrandBlue;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		height,
		page,
		burgerIn,
		searchIn,
		searchValue,
		colorBrandWhite,
		colorBrandRed,
		colorBrandDarkBlue,
		burgermenu_burgerIn_binding,
		burgermenu_page_binding,
		search_1_searchIn_binding,
		search_1_searchValue_binding,
		click_handler,
		click_handler_1,
		div1_elementresize_handler,
		div4_elementresize_handler,
		click_handler_2,
		click_handler_3,
		div3_elementresize_handler
	];
}

class Head extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			height: 0,
			page: 1,
			burgerIn: 2,
			searchIn: 3,
			searchValue: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Head",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*height*/ ctx[0] === undefined && !('height' in props)) {
			console.warn("<Head> was created without expected prop 'height'");
		}

		if (/*page*/ ctx[1] === undefined && !('page' in props)) {
			console.warn("<Head> was created without expected prop 'page'");
		}

		if (/*burgerIn*/ ctx[2] === undefined && !('burgerIn' in props)) {
			console.warn("<Head> was created without expected prop 'burgerIn'");
		}

		if (/*searchIn*/ ctx[3] === undefined && !('searchIn' in props)) {
			console.warn("<Head> was created without expected prop 'searchIn'");
		}

		if (/*searchValue*/ ctx[4] === undefined && !('searchValue' in props)) {
			console.warn("<Head> was created without expected prop 'searchValue'");
		}
	}

	get height() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get page() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set page(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get burgerIn() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set burgerIn(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchIn() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchIn(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchValue() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchValue(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Head as H, Icon as I, faInstagram as a, faTwitter as b, faFacebook as c, faYoutube as d, angleLeft as e, faTiktok as f };
//# sourceMappingURL=Head-9bde3955.js.map
